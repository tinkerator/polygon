package polygon

import (
	"fmt"
	"math"
	"testing"
)

// validate that the bounding box for a polygon is correct.
func (p *Shapes) chk(n int) error {
	p1 := p.P[n]
	var ll, tr Point
	for i, pt := range p1.PS {
		if i == 0 {
			ll = pt
			tr = pt
			continue
		}
		if pt.X < ll.X {
			ll.X = pt.X
		} else if pt.X > tr.X {
			tr.X = pt.X
		}
		if pt.Y < ll.Y {
			ll.Y = pt.Y
		} else if pt.Y > tr.Y {
			tr.Y = pt.Y
		}
	}
	if math.Abs(ll.X-p1.MinX) > Zeroish || math.Abs(ll.Y-p1.MinY) > Zeroish || math.Abs(tr.X-p1.MaxX) > Zeroish || math.Abs(tr.Y-p1.MaxY) > Zeroish {
		return fmt.Errorf("bad bounding box [%d]: %#v - vs %v %v", n, p1, ll, tr)
	}
	return nil
}

func TestIsLeft(t *testing.T) {
	vs := []struct {
		a, b, c Point
		want    bool
	}{
		{Point{0, .1}, Point{0, 0}, Point{1, 0}, true},
		{Point{.1, 0}, Point{0, 0}, Point{0, 1}, false},
	}
	for i, v := range vs {
		got := v.a.isLeft(v.b, v.c)
		if got != v.want {
			t.Fatalf("test=%d error see %v is left=%v of %v->%v", i, v.a, v.want, v.b, v.c)
		}
	}
}

func TestMinMax(t *testing.T) {
	vs := []struct{ x, y, a, b float64 }{
		{x: 1, y: 2, a: 1, b: 2},
		{x: 2, y: 1, a: 1, b: 2},
		{x: -1, y: -2, a: -2, b: -1},
		{x: -1, y: 1, a: -1, b: 1},
	}
	for i, v := range vs {
		a, b := MinMax(v.x, v.y)
		if a != v.a || b != v.b {
			t.Errorf("test=%d MinMax(%f,%f) failed: got a=%f, b=%f, wanted a=%f, b=%f", i, v.x, v.y, a, b, v.a, v.b)
		}
	}
}

func TestInside(t *testing.T) {
	var s *Shapes
	s = s.Builder([]Point{
		{102.02893679864614, 75.27038988683911},
		{102.0529527410619, 75.17135781555598},
		{102.11738387113262, 75.07488387113261},
		{102.21385781555601, 75.0104527410619},
		{102.31288988683914, 74.98643679864615},
		{107.93229226724219, 77.30370017967351},
		{107.77428982006037, 77.2758400852174},
		{107.6217024175717, 77.2262614327518},
		{107.47749999999999, 77.1559292143521},
		{107.34448930337548, 77.06621236664773},
		{107.22525922961054, 76.95885712602784},
		{107.12213045646881, 76.83595304013635},
		{107.03711026821223, 76.69989229720377},
		{106.9718534860962, 76.55332316482452},
		{106.92763025915612, 76.39909844444043},
		{106.9053013422012, 76.24021994480574},
		{106.9053013422012, 76.07978005519425},
		{106.92763025915612, 75.92090155555957},
		{106.96823644259132, 75.77929096493835},
		{104.19818512966441, 75.77929096493835},
		{104.18761612886739, 75.79511612886739},
		{104.09114218444398, 75.85954725893812},
		{103.99211011316088, 75.88356320135385},
		{102.31288988683914, 75.88356320135385},
		{102.21385781555601, 75.85954725893811},
		{102.1173838711326, 75.79511612886738},
		{102.05295274106189, 75.698642184444},
		{102.02893679864614, 75.59961011316088},
	}...)
	pt := Point{102.02893679864614, 76.54038988683912}
	if pt.Inside(s.P[0]) {
		t.Errorf("point %v should not be inside shape", pt)
	}

	s = nil
	s = s.Builder([]Point{
		{92.1053013422012, 73.53978005519426},
		{92.12763025915612, 73.38090155555957},
		{92.1718534860962, 73.22667683517548},
		{92.23711026821223, 73.08010770279623},
		{92.32213045646881, 72.94404695986366},
		{92.42525922961055, 72.82114287397216},
		{92.54448930337549, 72.71378763335227},
		{92.6775, 72.6240707856479},
		{92.8217024175717, 72.5537385672482},
		{92.97428982006038, 72.5041599147826},
		{93.13229226724219, 72.47629982032649},
		{93.29263442120788, 72.47070054892805},
		{93.45219540431697, 72.48747108403596},
		{93.60786954353118, 72.52628500626058},
		{93.75662681880743, 72.58638684675596},
		{93.89557183899136, 72.6666067915617},
		{94.02200019731268, 72.765383450701},
		{94.13345110958682, 72.88079424886048},
		{94.2277553105799, 73.01059284613181},
		{94.30307727628899, 73.15225286046284},
		{94.35795095032907, 73.30301704081046},
		{94.39130827905281, 73.45995093389593},
		{94.4025, 73.62},
		{94.39130827905281, 73.78004906610408},
		{94.38266573585358, 73.82070903506167},
		{97.1568148703356, 73.82070903506167},
		{97.16738387113261, 73.80488387113262},
		{97.26385781555598, 73.7404527410619},
		{97.36288988683911, 73.71643679864614},
		{99.04211011316089, 73.71643679864614},
		{99.14114218444402, 73.7404527410619},
		{99.23761612886739, 73.80488387113262},
		{99.3020472589381, 73.90135781555601},
		{99.32606320135385, 74.00038988683914},
		{99.32606320135385, 74.32961011316085},
		{99.3020472589381, 74.42864218444399},
		{99.23761612886739, 74.52511612886738},
		{99.14114218444402, 74.5895472589381},
		{99.04211011316089, 74.61356320135386},
		{97.36288988683911, 74.61356320135386},
		{97.26385781555598, 74.5895472589381},
		{97.16738387113261, 74.52511612886738},
		{97.15681487033561, 74.50929096493836},
		{93.97761896916393, 74.50929096493836},
		{93.89557183899136, 74.5733932084383},
		{93.75662681880743, 74.65361315324405},
		{93.6078695435312, 74.71371499373943},
		{93.45219540431697, 74.75252891596405},
		{93.29263442120788, 74.76929945107196},
		{93.13229226724219, 74.76370017967352},
		{92.97428982006038, 74.7358400852174},
		{92.8217024175717, 74.6862614327518},
		{92.6775, 74.61592921435211},
		{92.54448930337549, 74.52621236664774},
		{92.42525922961055, 74.41885712602785},
		{92.32213045646881, 74.29595304013635},
		{92.23711026821223, 74.15989229720378},
		{92.1718534860962, 74.01332316482453},
		{92.12763025915612, 73.85909844444043},
		{92.1053013422012, 73.70021994480575},
	}...)
	pt = Point{92.60249999999999, 73.62}
	if !pt.Inside(s.P[0]) {
		t.Errorf("point %v should be inside shape", pt)
	}

	s = nil
	s = s.Builder([]Point{
		{92.1053013422012, 76.07978005519425},
		{92.12763025915612, 75.92090155555957},
		{92.1718534860962, 75.76667683517547},
		{92.23711026821223, 75.62010770279622},
		{92.32213045646881, 75.48404695986365},
		{92.42525922961055, 75.36114287397216},
		{92.54448930337549, 75.25378763335226},
		{92.6775, 75.1640707856479},
		{92.8217024175717, 75.0937385672482},
		{92.97428982006038, 75.0441599147826},
		{93.13229226724219, 75.01629982032648},
		{93.29263442120788, 75.01070054892804},
		{93.45219540431697, 75.02747108403595},
		{93.60786954353118, 75.06628500626057},
		{93.75662681880743, 75.12638684675595},
		{93.80494728004479, 75.1542846780587},
		{93.8543600286833, 75.13771381117687},
		{93.94879874257262, 75.09070903506165},
		{97.1568148703356, 75.09070903506165},
		{97.16738387113261, 75.07488387113261},
		{97.26385781555601, 75.0104527410619},
		{97.36288988683914, 74.98643679864615},
		{99.04211011316086, 74.98643679864615},
		{99.14114218444399, 75.0104527410619},
		{99.23761612886739, 75.07488387113261},
		{99.3020472589381, 75.17135781555601},
		{99.32606320135385, 75.27038988683914},
		{99.32606320135385, 75.59961011316085},
		{99.30204725893812, 75.69864218444397},
		{99.2376161288674, 75.79511612886738},
		{99.14114218444399, 75.85954725893811},
		{99.04211011316086, 75.88356320135385},
		{97.36288988683914, 75.88356320135385},
		{97.26385781555601, 75.85954725893811},
		{97.1673838711326, 75.79511612886738},
		{97.1568148703356, 75.77929096493835},
		{94.33475655556505, 75.77929096493835},
		{94.35795095032907, 75.84301704081045},
		{94.39130827905281, 75.99995093389592},
		{94.4025, 76.16},
		{94.39130827905281, 76.32004906610408},
		{94.35795095032907, 76.47698295918954},
		{94.30307727628899, 76.62774713953716},
		{94.2277553105799, 76.76940715386819},
		{94.13345110958683, 76.89920575113952},
		{94.02200019731268, 77.014616549299},
		{93.89557183899136, 77.1133932084383},
		{93.75662681880743, 77.19361315324404},
		{93.6078695435312, 77.25371499373942},
		{93.45219540431697, 77.29252891596404},
		{93.29263442120788, 77.30929945107195},
		{93.13229226724219, 77.30370017967351},
		{92.97428982006038, 77.2758400852174},
		{92.8217024175717, 77.2262614327518},
		{92.6775, 77.1559292143521},
		{92.54448930337549, 77.06621236664773},
		{92.42525922961055, 76.95885712602784},
		{92.32213045646881, 76.83595304013635},
		{92.23711026821223, 76.69989229720377},
		{92.1718534860962, 76.55332316482452},
		{92.12763025915612, 76.39909844444043},
		{92.1053013422012, 76.24021994480574},
	}...)
	pt = Point{92.60249999999999, 76.16}
	if !pt.Inside(s.P[0]) {
		t.Errorf("point %v should be inside shape", pt)
	}
}

func TestDissolve(t *testing.T) {
	s := &Shape{
		MinX: 101.6096,
		MinY: 64.3607,
		MaxX: 102.2596,
		MaxY: 64.5893,
		Hole: false,
		PS: []Point{
			{101.6346, 64.3857},
			{101.68459999999999, 64.3857},
			{101.6846, 64.49999999999999},
			{101.68459999999999, 64.56429999999999},
			{101.6346, 64.56429999999999},
		},
	}
	s, changed := s.dissolve()
	if len(s.PS) != 4 {
		t.Errorf("unexpected length for s = %v (changed=%v)", s, changed)
	}
}

func TestUnion(t *testing.T) {
	var ss *Shapes
	var err error
	ss, err = ss.Append(Point{0, 0}, Point{2, 0}, Point{2, 2}, Point{0, 2})
	if ss == nil || err != nil {
		t.Fatalf("failed to add first square: %v", err)
	}
	if ss.P[0].Hole {
		t.Fatalf("counter-clockwise shape is a hole: %#v", *ss.P[0])
	}
	ss = ss.Builder(Point{1, 1}, Point{1, 3}, Point{3, 3}, Point{3, 1})
	if len(ss.P) != 2 {
		t.Fatalf("failed to add second shape, only %d shapes recorded", len(ss.P))
	}
	if !ss.P[1].Hole {
		t.Fatalf("clockwise shape is not a hole: %#v", *ss.P[1])
	}
	if err = ss.Invert(3); err == nil {
		t.Fatal("invalid polygon shape inversion performed?")
	}
	if err = ss.Invert(1); err != nil {
		t.Fatalf("polygon shape inversion failed: %v", err)
	}
	if ss.P[1].Hole {
		t.Fatalf("counter-clockwise shape is still a hole: %#v", *ss.P[1])
	}
	ss = ss.Builder(Point{0, 4}, Point{2, 4}, Point{2, 6}, Point{0, 6})
	if len(ss.P) != 3 {
		t.Fatalf("failed to add second shape, only %d shapes recorded", len(ss.P))
	}
	if ss.P[2].Hole {
		t.Fatalf("counter-clockwise shape is a hole: %#v", *ss.P[2])
	}
	ss = ss.Builder(Point{1, 5}, Point{3, 5}, Point{3, 7}, Point{1, 7})
	if len(ss.P) != 4 {
		t.Fatalf("failed to add second shape, only %d shapes recorded", len(ss.P))
	}
	if ss.P[3].Hole {
		t.Fatalf("counter-clockwise shape is a hole: %#v", *ss.P[2])
	}
	ss.Union()
	if len(ss.P) != 2 {
		t.Fatalf("post union shape count != 2, got=%d", len(ss.P))
	}
	us := ss.P[0].PS
	if len(us) != 8 {
		t.Fatalf("expecting 8 post union points: got=%v", us)
	}
	expect := []Point{{0, 0}, {2, 0}, {2, 1}, {3, 1}, {3, 3}, {1, 3}, {1, 2}, {0, 2}}
	for i, got := range us {
		if want := expect[i]; got != want {
			t.Errorf("union[0] point[%d]: got=%v, want=%v", i, got, want)
		}
	}
	us = ss.P[1].PS
	expect = []Point{{0, 4}, {2, 4}, {2, 5}, {3, 5}, {3, 7}, {1, 7}, {1, 6}, {0, 6}}
	if len(us) != len(expect) {
		t.Fatalf("expecting %d post union points: got=%v, want=%v", len(expect), us, expect)
	}
	for i, got := range us {
		if want := expect[i]; got != want {
			t.Errorf("union[1] point[%d]: got=%v, want=%v", i, got, want)
		}
	}

	ss = nil
	ss = ss.Builder([]Point{
		{X: 1, Y: 1},
		{X: 2, Y: 1},
		{X: 2, Y: 2},
		{X: 1, Y: 2},
	}...).Builder([]Point{
		{X: 2, Y: 0},
		{X: 3, Y: 0},
		{X: 3, Y: 2},
		{X: 2, Y: 2},
	}...)
	ss.Union()
	if len(ss.P) != 1 {
		t.Fatalf("expecting a single poly, but got %d", len(ss.P))
	}
	us = ss.P[0].PS
	expect = []Point{{1, 1}, {2, 1}, {2, 0}, {3, 0}, {3, 2}, {1, 2}}
	if len(us) != len(expect) {
		t.Fatalf("expecting %d post union points: got=%v, want=%v", len(expect), us, expect)
	}
	for i, got := range us {
		if want := expect[i]; got != want {
			t.Errorf("union[0] point[%d]: got=%v, want=%v", i, got, want)
		}
	}

	// Validate coincident heavy overlaps.
	ss = nil
	ss = ss.Builder([]Point{
		{X: 1, Y: 1},
		{X: 2, Y: 1},
		{X: 2, Y: 2},
		{X: 1, Y: 2},
	}...).Builder([]Point{
		{X: 0, Y: 0},
		{X: 1.5, Y: 0},
		{X: 1.5, Y: 1},
		{X: 0, Y: 1},
	}...)
	ss.Union()
	if len(ss.P) != 1 {
		t.Fatalf("expecting a single poly, but got %d", len(ss.P))
	}
	us = ss.P[0].PS
	expect = []Point{{0, 0}, {1.5, 0}, {1.5, 1}, {2, 1}, {2, 2}, {1, 2}, {1, 1}, {0, 1}}
	if len(us) != len(expect) {
		t.Fatalf("expecting %d post union points: got=%v, want=%v", len(expect), us, expect)
	}
	for i, got := range us {
		if want := expect[i]; got != want {
			t.Errorf("union[0] point[%d]: got=%v, want=%v", i, got, want)
		}
	}

	ss = nil
	ss = ss.Builder([]Point{
		{X: 1, Y: 1},
		{X: 2, Y: 1},
		{X: 2, Y: 2},
		{X: 1, Y: 2},
	}...).Builder([]Point{
		{X: 2, Y: 0},
		{X: 3, Y: 0},
		{X: 3, Y: 3},
		{X: 2, Y: 3},
	}...)
	ss.Union()
	if len(ss.P) != 1 {
		t.Fatalf("expecting a single poly, but got %d", len(ss.P))
	}
	us = ss.P[0].PS
	expect = []Point{{1, 1}, {2, 1}, {2, 0}, {3, 0}, {3, 3}, {2, 3}, {2, 2}, {1, 2}}
	if len(us) != len(expect) {
		t.Fatalf("expecting %d post union points: got=%v, want=%v", len(expect), us, expect)
	}
	for i, got := range us {
		if want := expect[i]; got != want {
			t.Errorf("union[0] point[%d]: got=%v, want=%v", i, got, want)
		}
	}

	ss = nil
	ss = ss.Builder([]Point{
		{X: 1, Y: 0},
		{X: 2, Y: 0},
		{X: 2, Y: 3},
		{X: 1, Y: 3},
	}...).Builder([]Point{
		{X: 2, Y: 1},
		{X: 3, Y: 1},
		{X: 3, Y: 2},
		{X: 2, Y: 2},
	}...)
	ss.Union()
	if len(ss.P) != 1 {
		t.Fatalf("expecting a single poly, but got %d", len(ss.P))
	}
	us = ss.P[0].PS
	expect = []Point{{1, 0}, {2, 0}, {2, 1}, {3, 1}, {3, 2}, {2, 2}, {2, 3}, {1, 3}}
	if len(us) != len(expect) {
		t.Fatalf("expecting %d post union points: got=%v, want=%v", len(expect), us, expect)
	}
	for i, got := range us {
		if want := expect[i]; got != want {
			t.Errorf("union[0] point[%d]: got=%v, want=%v", i, got, want)
		}
	}

	// First poly fully contained in second.
	ss = nil
	ss = ss.Builder([]Point{
		{X: 1, Y: 1},
		{X: 2, Y: 1},
		{X: 2, Y: 2},
		{X: 1, Y: 2},
	}...).Builder([]Point{
		{X: 0, Y: 0},
		{X: 3, Y: 0},
		{X: 3, Y: 3},
		{X: 0, Y: 3},
	}...)
	ss.Union()
	if len(ss.P) != 1 {
		t.Fatalf("expecting a single poly, but got %d", len(ss.P))
	}
	us = ss.P[0].PS
	expect = []Point{{0, 0}, {3, 0}, {3, 3}, {0, 3}}
	if len(us) != len(expect) {
		t.Fatalf("expecting %d post union points: got=%v, want=%v", len(expect), us, expect)
	}
	for i, got := range us {
		if want := expect[i]; got != want {
			t.Errorf("union[0] point[%d]: got=%v, want=%v", i, got, want)
		}
	}

	// first poly subset of second against corner.
	ss = nil
	ss = ss.Builder([]Point{
		{X: 0, Y: 0},
		{X: 2, Y: 0},
		{X: 2, Y: 2},
		{X: 0, Y: 2},
	}...).Builder([]Point{
		{X: 0, Y: 0},
		{X: 3, Y: 0},
		{X: 3, Y: 3},
		{X: 0, Y: 3},
	}...)
	ss.Union()
	if len(ss.P) != 1 {
		t.Fatalf("expecting a single poly, but got %d", len(ss.P))
	}
	us = ss.P[0].PS
	expect = []Point{{0, 0}, {3, 0}, {3, 3}, {0, 3}}
	if len(us) != len(expect) {
		t.Fatalf("expecting %d post union points: got=%v, want=%v", len(expect), us, expect)
	}
	for i, got := range us {
		if want := expect[i]; got != want {
			t.Errorf("union[0] point[%d]: got=%v, want=%v", i, got, want)
		}
	}

	ss = nil
	ss = ss.Builder([]Point{
		{X: 0, Y: 0},
		{X: 3, Y: 0},
		{X: 3, Y: 1},
		{X: 0, Y: 1},
	}...).Builder([]Point{
		{X: 2, Y: 0},
		{X: 4, Y: 0},
		{X: 4, Y: 2},
		{X: 2, Y: 2},
	}...)
	ss.Union()
	if len(ss.P) != 1 {
		t.Fatalf("expecting a single poly, but got %d", len(ss.P))
	}
	us = ss.P[0].PS
	expect = []Point{{0, 0}, {4, 0}, {4, 2}, {2, 2}, {2, 1}, {0, 1}}
	if len(us) != len(expect) {
		t.Fatalf("expecting %d post union points: got=%v, want=%v", len(expect), us, expect)
	}
	for i, got := range us {
		if want := expect[i]; got != want {
			t.Errorf("union[0] point[%d]: got=%v, want=%v", i, got, want)
		}
	}

	ss = nil
	ss = ss.Builder([]Point{
		{X: 0, Y: 0},
		{X: 5, Y: 0},
		{X: 5, Y: 1},
		{X: 0, Y: 1},
	}...).Builder([]Point{
		{X: 1, Y: 2},
		{X: 5, Y: 2},
		{X: 5, Y: 3},
		{X: 1, Y: 3},
	}...).Builder([]Point{
		{X: 4, Y: 0},
		{X: 5, Y: 0},
		{X: 5, Y: 3},
		{X: 4, Y: 3},
	}...)
	ss.Union()
	if len(ss.P) != 1 {
		t.Errorf("expecting a single poly, but got %d", len(ss.P))
		for i := 0; i < len(ss.P); i++ {
			t.Errorf("P[%d] = %#v", i, *ss.P[i])
		}
	}
	us = ss.P[0].PS
	expect = []Point{{0, 0}, {5, 0}, {5, 3}, {1, 3}, {1, 2}, {4, 2}, {4, 1}, {0, 1}}
	if len(us) != len(expect) {
		t.Fatalf("expecting %d post union points: got=%v, want=%v", len(expect), us, expect)
	}
	for i, got := range us {
		if want := expect[i]; got != want {
			t.Errorf("union[0] point[%d]: got=%v, want=%v", i, got, want)
		}
	}

	ss = nil
	ss = ss.Builder([]Point{
		{X: 0.0000002, Y: 2},
		{X: 1, Y: 2},
		{X: 1, Y: 3},
		{X: 0, Y: 3},
	}...).Builder([]Point{
		{X: 0.0000001, Y: 2},
		{X: 1, Y: 1},
		{X: 2, Y: 2},
		{X: 1, Y: 3},
	}...)
	ss.Union()
	if len(ss.P) != 1 {
		t.Fatalf("expecting a single poly, but got %d", len(ss.P))
	}
	us = ss.P[0].PS
	expect = []Point{{0, 3}, {0.0000002, 2}, {1, 1}, {2, 2}, {1, 3}}
	if len(us) != len(expect) {
		t.Fatalf("expecting %d post union points: got=%v, want=%v", len(expect), us, expect)
	}
	for i, got := range us {
		if want := expect[i]; got != want {
			t.Errorf("union[0] point[%d]: got=%v, want=%v", i, got, want)
		}
	}

	ss = nil
	ss = ss.Builder([]Point{
		{93.6, 72.6},
		{93.7, 72.7},
		{92.2, 73.7},
	}...).Builder([]Point{
		{93.0, 73.7},
		{93.0, 73.4},
		{93.6, 74.3},
	}...)
	ss.Union()
	if len(ss.P) != 2 {
		t.Fatalf("expecting two polys, but got %d", len(ss.P))
	}
	us = ss.P[0].PS
	expect = []Point{{92.2, 73.7}, {93.6, 72.6}, {93.7, 72.7}}
	if len(us) != len(expect) {
		t.Fatalf("expecting %d post union[0] points: got=%v, want=%v", len(expect), us, expect)
	}
	for i, got := range us {
		if want := expect[i]; got != want {
			t.Errorf("union[0] point[%d]: got=%v, want=%v", i, got, want)
		}
	}
	us = ss.P[1].PS
	expect = []Point{{93.0, 73.4}, {93.6, 74.3}, {93.0, 73.7}}
	if len(us) != len(expect) {
		t.Fatalf("expecting %d post union[1] points: got=%v, want=%v", len(expect), us, expect)
	}
	for i, got := range us {
		if want := expect[i]; got != want {
			t.Errorf("union[1] point[%d]: got=%v, want=%v", i, got, want)
		}
	}
}

func TestVoids(t *testing.T) {
	var ss *Shapes
	ss = ss.Builder([]Point{
		{0, 0}, {4, 0}, {4, 2}, {2, 2}, {2, 4}, {0, 4},
	}...).Builder([]Point{
		{1, 3}, {3, 3}, {3, 1}, {5, 1}, {5, 5}, {1, 5},
	}...)
	ss.Union()
	if len(ss.P) != 2 {
		t.Fatalf("expecting two polys, but got %d", len(ss.P))
	}
	failed := ss.P[0].Hole || !ss.P[1].Hole
	if failed {
		for i, p := range ss.P {
			t.Errorf("p[%d] = %v", i, p)
		}
	}
}

func TestIntersect(t *testing.T) {
	vs := []struct {
		a, b, c, d, at  Point
		hit, left, hold bool
	}{
		{
			a:    Point{X: 0.0, Y: 0.0},
			b:    Point{X: 1.0, Y: 0.0},
			c:    Point{X: 0.1, Y: 0.1},
			d:    Point{X: 0.1, Y: 1.0},
			hit:  false,
			left: true,
			hold: true,
			at:   Point{X: 92.062470, Y: 72.33},
		},
		{
			a:    Point{X: 0.1, Y: 0.1},
			b:    Point{X: 0.1, Y: 1.0},
			c:    Point{X: 1.0, Y: 0.0},
			d:    Point{X: 0.0, Y: 0.0},
			hit:  false,
			left: false,
			hold: false,
			at:   Point{X: 92.062470, Y: 72.33},
		},
		{
			a:    Point{X: 96.38225424859374, Y: 74.72694631307311},
			b:    Point{X: 96.35022032262698, Y: 74.75022032262696},
			c:    Point{X: 96.35022032262697, Y: 74.75022032262696},
			d:    Point{X: 96.25725424859374, Y: 74.81776412907378},
			hit:  true,
			left: true,
			hold: true,
			at:   Point{X: 96.35022032262697, Y: 74.75022032262696},
		},
		{
			a:    Point{X: 92.0432020322183, Y: 72.27706055336469},
			b:    Point{X: 92.09680528764137, Y: 72.42433428724885},
			c:    Point{X: 91.44, Y: 72.33},
			d:    Point{X: 96.1048, Y: 72.33},
			hit:  true,
			hold: true,
			left: false,
			at:   Point{X: 92.062470, Y: 72.33},
		},
		{
			a:    Point{92.60249999999999, 76.16},
			b:    Point{100.32606320135385, 76.16},
			c:    Point{94.39130827905281, 75.99995093389592},
			d:    Point{94.4025, 76.16},
			hit:  true,
			hold: false,
			left: true,
			at:   Point{94.4025, 76.16},
		},
	}
	for i, v := range vs {
		hit, left, hold, at := intersect(v.a, v.b, v.c, v.d)
		if hold != v.hold {
			t.Errorf("test=%d: hold got=%v, want=%v", i, hold, v.hold)
		}
		if left != v.left {
			t.Errorf("test=%d: left got=%v, want=%v", i, left, v.left)
		}
		if hit != v.hit {
			t.Fatalf("test=%d: hit got=%v, want=%v", i, hit, v.hit)
		}
		if !hit {
			continue
		}
		if !MatchPoint(v.at, at) {
			t.Errorf("test=%d got=%v, want=%v", i, at, v.at)
		}
	}
}

func TestTrace(t *testing.T) {
	pts := [][]Point{
		[]Point{{X: 97.35, Y: 68.58}, {X: 97.23, Y: 68.80}, {X: 96.98, Y: 68.80}, {X: 96.85, Y: 68.58}, {X: 96.98, Y: 68.36}, {X: 97.23, Y: 68.36}},
		[]Point{{X: 91.44, Y: 68.33}, {X: 97.10, Y: 68.33}, {X: 97.10, Y: 68.83}, {X: 91.44, Y: 68.83}},
		[]Point{{X: 91.69, Y: 68.58}, {X: 91.57, Y: 68.80}, {X: 91.32, Y: 68.80}, {X: 91.19, Y: 68.58}, {X: 91.32, Y: 68.36}, {X: 91.57, Y: 68.36}},
	}
	var s *Shapes
	for i, ps := range pts {
		var err error
		s, err = s.Append(ps...)
		if err != nil {
			t.Fatalf("shape=%d failed import: %v", i, err)
		}
		s.Union()
		if len(s.P) != 1 {
			t.Fatalf("after shape=%d unioned, got=%d shapes, want=1: %v", i, len(s.P), s.P)
		}
	}
	us := s.P[0].PS
	expect := []Point{
		{X: 91.19, Y: 68.58},
		{X: 91.32, Y: 68.36},
		{X: 91.44, Y: 68.36},
		{X: 91.44, Y: 68.33},
		{X: 97.10, Y: 68.33},
		{X: 97.10, Y: 68.36},
		{X: 97.23, Y: 68.36},
		{X: 97.35, Y: 68.58},
		{X: 97.23, Y: 68.80},
		{X: 97.10, Y: 68.80},
		{X: 97.10, Y: 68.83},
		{X: 91.44, Y: 68.83},
		{X: 91.44, Y: 68.80},
		{X: 91.32, Y: 68.80},
	}
	if len(us) != len(expect) {
		t.Fatalf("expecting %d post union points: got=%v, want=%v", len(expect), us, expect)
	}
	for i, got := range us {
		if want := expect[i]; !MatchPoint(got, want) {
			t.Errorf("point[%d]: got=%v, want=%v", i, got, want)
		}
	}

	pts = [][]Point{
		[]Point{
			{X: 91.190000, Y: 74.580000},
			{X: 91.237746, Y: 74.433054},
			{X: 91.362746, Y: 74.342236},
			{X: 91.440000, Y: 74.342236},
			{X: 91.440000, Y: 74.330000},
			{X: 96.180000, Y: 74.330000},
			{X: 96.180000, Y: 74.342236},
			{X: 96.257254, Y: 74.342236},
			{X: 96.382254, Y: 74.433054},
			{X: 96.430000, Y: 74.580000},
			{X: 96.382254, Y: 74.726946},
			{X: 96.257254, Y: 74.817764},
			{X: 96.180000, Y: 74.817764},
			{X: 96.180000, Y: 74.830000},
			{X: 91.440000, Y: 74.830000},
			{X: 91.440000, Y: 74.817764},
			{X: 91.362746, Y: 74.817764},
			{X: 91.237746, Y: 74.726946},
		},
		[]Point{
			{X: 95.930000, Y: 74.580000},
			{X: 95.977746, Y: 74.433054},
			{X: 96.009780, Y: 74.409780},
			{X: 96.003223, Y: 74.403223},
			{X: 96.343223, Y: 74.063223},
			{X: 96.349780, Y: 74.069780},
			{X: 96.442746, Y: 74.002236},
			{X: 96.597254, Y: 74.002236},
			{X: 96.722254, Y: 74.093054},
			{X: 96.770000, Y: 74.240000},
			{X: 96.722254, Y: 74.386946},
			{X: 96.690220, Y: 74.410220},
			{X: 96.696777, Y: 74.416777},
			{X: 96.356777, Y: 74.756777},
			{X: 96.350220, Y: 74.750220},
			{X: 96.257254, Y: 74.817764},
			{X: 96.102746, Y: 74.817764},
			{X: 95.977746, Y: 74.726946},
		},
	}
	s = nil
	for i, ps := range pts {
		var err error
		s, err = s.Append(ps...)
		if err != nil {
			t.Fatalf("shape=%d failed import: %v", i, err)
		}
		s.Union()
		if len(s.P) != 1 {
			t.Fatalf("after shape=%d unioned, got=%d shapes, want=1: %v", i, len(s.P), s.P)
		}
	}
	expect = []Point{
		{X: 91.19, Y: 74.58},
		{X: 91.237746, Y: 74.433054},
		{X: 91.362746, Y: 74.342236},
		{X: 91.44, Y: 74.342236},
		{X: 91.44, Y: 74.33},
		{X: 96.07644599999999, Y: 74.33},
		{X: 96.343223, Y: 74.063223},
		{X: 96.34978, Y: 74.06978},
		{X: 96.442746, Y: 74.002236},
		{X: 96.597254, Y: 74.002236},
		{X: 96.722254, Y: 74.093054},
		{X: 96.77, Y: 74.24},
		{X: 96.722254, Y: 74.386946},
		{X: 96.69022, Y: 74.41022},
		{X: 96.696777, Y: 74.416777},
		{X: 96.356777, Y: 74.756777},
		{X: 96.35022006399838, Y: 74.75022006399838},
		{X: 96.257254, Y: 74.817764},
		{X: 96.18, Y: 74.817764},
		{X: 96.18, Y: 74.83},
		{X: 91.44, Y: 74.83},
		{X: 91.44, Y: 74.817764},
		{X: 91.362746, Y: 74.817764},
		{X: 91.237746, Y: 74.726946},
	}
	us = s.P[0].PS
	if len(us) != len(expect) {
		t.Fatalf("expecting %d post union points, but see=%d points: got=%#v, want=%#v", len(expect), len(us), us, expect)
	}
	for i, got := range us {
		if want := expect[i]; !MatchPoint(got, want) {
			t.Errorf("point[%d]: got=%v, want=%v", i, got, want)
		}
	}

	pts = [][]Point{
		[]Point{
			{X: 90.7695641085242, Y: 72.50163728296546},
			{X: 90.80570748096952, Y: 72.34913640325517},
			{X: 90.87604572729627, Y: 72.2090814398022},
			{X: 90.9767868944386, Y: 72.08902279193819},
			{X: 91.10249999999999, Y: 71.9954328524455},
			{X: 91.24640781792002, Y: 71.93335707918705},
			{X: 91.40075224048543, Y: 71.9061419931669},
			{X: 91.55721251992517, Y: 71.91525476671676},
			{X: 91.70735384207643, Y: 71.96020412785582},
			{X: 91.84308204939938, Y: 72.03856684489034},
			{X: 91.9570799991053, Y: 72.14611836346158},
			{X: 92.0432020322183, Y: 72.27706055336469},
			{X: 92.09680528764137, Y: 72.42433428724885},
			{X: 92.115, Y: 72.58},
			{X: 92.09680528764137, Y: 72.73566571275114},
			{X: 92.0432020322183, Y: 72.8829394466353},
			{X: 91.9570799991053, Y: 73.01388163653841},
			{X: 91.84308204939938, Y: 73.12143315510966},
			{X: 91.70735384207643, Y: 73.19979587214418},
			{X: 91.55721251992517, Y: 73.24474523328324},
			{X: 91.40075224048543, Y: 73.2538580068331},
			{X: 91.24640781792002, Y: 73.22664292081295},
			{X: 91.10249999999999, Y: 73.1645671475545},
			{X: 90.9767868944386, Y: 73.0709772080618},
			{X: 90.87604572729627, Y: 72.95091856019779},
			{X: 90.80570748096952, Y: 72.81086359674482},
			{X: 90.7695641085242, Y: 72.65836271703454},
		},
		[]Point{
			{X: 91.19, Y: 72.58},
			{X: 91.23774575140627, Y: 72.43305368692688},
			{X: 91.36274575140627, Y: 72.34223587092622},
			{X: 91.44, Y: 72.3422358709262},
			{X: 91.44, Y: 72.33},
			{X: 96.1048, Y: 72.33},
			{X: 96.1048, Y: 72.34223587092622},
			{X: 96.18205424859373, Y: 72.3422358709262},
			{X: 96.30705424859373, Y: 72.43305368692688},
			{X: 96.3548, Y: 72.58},
			{X: 96.30705424859373, Y: 72.72694631307311},
			{X: 96.18205424859373, Y: 72.81776412907378},
			{X: 96.1048, Y: 72.8177641290738},
			{X: 96.1048, Y: 72.83},
			{X: 91.44, Y: 72.83},
			{X: 91.44, Y: 72.81776412907378},
			{X: 91.36274575140627, Y: 72.8177641290738},
			{X: 91.23774575140627, Y: 72.72694631307311},
		},
	}
	s = nil
	for i, ps := range pts {
		var err error
		s, err = s.Append(ps...)
		if err != nil {
			t.Fatalf("shape=%d failed import: %v", i, err)
		}
		s.Union()
		if len(s.P) != 1 {
			t.Fatalf("after shape=%d unioned, got=%d shapes, want=1: %v", i, len(s.P), s.P)
		}
	}
	expect = []Point{
		{X: 90.7695641085242, Y: 72.50163728296546},
		{X: 90.80570748096952, Y: 72.34913640325517},
		{X: 90.87604572729627, Y: 72.2090814398022},
		{X: 90.9767868944386, Y: 72.08902279193819},
		{X: 91.10249999999999, Y: 71.9954328524455},
		{X: 91.24640781792002, Y: 71.93335707918705},
		{X: 91.40075224048543, Y: 71.9061419931669},
		{X: 91.55721251992517, Y: 71.91525476671676},
		{X: 91.70735384207643, Y: 71.96020412785582},
		{X: 91.84308204939938, Y: 72.03856684489034},
		{X: 91.9570799991053, Y: 72.14611836346158},
		{X: 92.0432020322183, Y: 72.27706055336469},
		{X: 92.06247041501207, Y: 72.32999999999998},
		{X: 96.1048, Y: 72.33},
		{X: 96.1048, Y: 72.34223587092622},
		{X: 96.18205424859373, Y: 72.3422358709262},
		{X: 96.30705424859373, Y: 72.43305368692688},
		{X: 96.3548, Y: 72.58},
		{X: 96.30705424859373, Y: 72.72694631307311},
		{X: 96.18205424859373, Y: 72.81776412907378},
		{X: 96.1048, Y: 72.8177641290738},
		{X: 96.1048, Y: 72.83},
		{X: 92.06247041501207, Y: 72.82999999999998},
		{X: 92.0432020322183, Y: 72.8829394466353},
		{X: 91.9570799991053, Y: 73.01388163653841},
		{X: 91.84308204939938, Y: 73.12143315510966},
		{X: 91.70735384207643, Y: 73.19979587214418},
		{X: 91.55721251992517, Y: 73.24474523328324},
		{X: 91.40075224048543, Y: 73.2538580068331},
		{X: 91.24640781792002, Y: 73.22664292081295},
		{X: 91.10249999999999, Y: 73.1645671475545},
		{X: 90.9767868944386, Y: 73.0709772080618},
		{X: 90.87604572729627, Y: 72.95091856019779},
		{X: 90.80570748096952, Y: 72.81086359674482},
		{X: 90.7695641085242, Y: 72.65836271703454},
	}
	us = s.P[0].PS
	if len(us) != len(expect) {
		t.Fatalf("expecting %d post union points, but see=%d points: got=%#v, want=%#v", len(expect), len(us), us, expect)
	}
	for i, got := range us {
		if want := expect[i]; !MatchPoint(got, want) {
			t.Errorf("point[%d]: got=%v, want=%v", i, got, want)
		}
	}

	pts = [][]Point{
		[]Point{
			{X: 90.765, Y: 67.905},
			{X: 92.115, Y: 67.905},
			{X: 92.115, Y: 68.33},
			{X: 97.1, Y: 68.33},
			{X: 97.1, Y: 68.34223587092622},
			{X: 97.17725424859373, Y: 68.3422358709262},
			{X: 97.30225424859373, Y: 68.43305368692688},
			{X: 97.35, Y: 68.58},
			{X: 97.30225424859373, Y: 68.72694631307311},
			{X: 97.17725424859373, Y: 68.81776412907378},
			{X: 97.1, Y: 68.8177641290738},
			{X: 97.1, Y: 68.83},
			{X: 92.115, Y: 68.83},
			{X: 92.115, Y: 69.255},
			{X: 90.765, Y: 69.255},
		},
		[]Point{
			{X: 96.85, Y: 68.58},
			{X: 96.89774575140626, Y: 68.43305368692688},
			{X: 97.02274575140626, Y: 68.34223587092622},
			{X: 97.17725424859373, Y: 68.3422358709262},
			{X: 97.27022032262697, Y: 68.40977967737305},
			{X: 97.27677669529663, Y: 68.40322330470336},
			{X: 97.91177669529664, Y: 69.03822330470337},
			{X: 97.90522032262695, Y: 69.04477967737304},
			{X: 97.93725424859373, Y: 69.06805368692689},
			{X: 97.985, Y: 69.215},
			{X: 97.93725424859373, Y: 69.36194631307312},
			{X: 97.81225424859373, Y: 69.45276412907378},
			{X: 97.65774575140627, Y: 69.45276412907378},
			{X: 97.56477967737304, Y: 69.38522032262695},
			{X: 97.55822330470336, Y: 69.39177669529664},
			{X: 96.92322330470336, Y: 68.75677669529664},
			{X: 96.92977967737303, Y: 68.75022032262696},
			{X: 96.89774575140626, Y: 68.72694631307311},
		},
	}
	s = nil
	for i, ps := range pts {
		var err error
		s, err = s.Append(ps...)
		if err != nil {
			t.Fatalf("shape=%d failed import: %v", i, err)
		}
		s.Union()
		if len(s.P) != 1 {
			t.Fatalf("after shape=%d unioned, got=%d shapes, want=1: %v", i, len(s.P), s.P)
		}
	}
	expect = []Point{
		{X: 90.765, Y: 67.905},
		{X: 92.115, Y: 67.905},
		{X: 92.115, Y: 68.33},
		{X: 97.1, Y: 68.33},
		{X: 97.1, Y: 68.34223587092622},
		{X: 97.17725424859373, Y: 68.3422358709262},
		{X: 97.27022032262697, Y: 68.40977967737305},
		{X: 97.27677669529663, Y: 68.40322330470336},
		{X: 97.91177669529664, Y: 69.03822330470337},
		{X: 97.90522032262695, Y: 69.04477967737304},
		{X: 97.93725424859373, Y: 69.06805368692689},
		{X: 97.985, Y: 69.215},
		{X: 97.93725424859373, Y: 69.36194631307312},
		{X: 97.81225424859373, Y: 69.45276412907378},
		{X: 97.65774575140627, Y: 69.45276412907378},
		{X: 97.56477967737304, Y: 69.38522032262695},
		{X: 97.55822330470336, Y: 69.39177669529664},
		{X: 96.99644660940672, Y: 68.83},
		{X: 92.115, Y: 68.83},
		{X: 92.115, Y: 69.255},
		{X: 90.765, Y: 69.255},
	}
	us = s.P[0].PS
	if len(us) != len(expect) {
		t.Fatalf("expecting %d post union points, but see=%d points: got=%#v, want=%#v", len(expect), len(us), us, expect)
	}
	for i, got := range us {
		if want := expect[i]; !MatchPoint(got, want) {
			t.Errorf("point[%d]: got=%v, want=%v", i, got, want)
		}
	}

	pts = [][]Point{
		[]Point{
			{X: 93.0525, Y: 76.16},
			{X: 93.11107864376268, Y: 76.01857864376268},
			{X: 93.2525, Y: 75.96},
			{X: 93.39392135623731, Y: 76.01857864376268},
			{X: 93.4525, Y: 76.16},
			{X: 93.39392135623731, Y: 76.30142135623731},
			{X: 93.2525, Y: 76.36},
			{X: 93.11107864376268, Y: 76.30142135623731},
		},
		[]Point{
			{X: 93.1110786437627, Y: 76.01857864376268},
			{X: 93.8360786437627, Y: 75.29357864376269},
			{X: 94.11892135623731, Y: 75.57642135623732},
			{X: 93.3939213562373, Y: 76.30142135623731},
		},
		[]Point{
			{X: 93.7775, Y: 75.435},
			{X: 93.83607864376269, Y: 75.29357864376269},
			{X: 93.9775, Y: 75.235},
			{X: 94.11892135623732, Y: 75.29357864376269},
			{X: 94.17750000000001, Y: 75.435},
			{X: 94.11892135623732, Y: 75.57642135623732},
			{X: 93.9775, Y: 75.635},
			{X: 93.83607864376269, Y: 75.57642135623732},
		},
	}
	s = nil
	for i, ps := range pts {
		var err error
		s, err = s.Append(ps...)
		if err != nil {
			t.Fatalf("shape=%d failed import: %v", i, err)
		}
		s.Union()
		if len(s.P) != 1 {
			t.Fatalf("after shape=%d unioned, got=%d shapes, want=1: %v", i, len(s.P), s.P)
		}
	}
	expect = []Point{
		{X: 93.0525, Y: 76.16},
		{X: 93.11107864376268, Y: 76.01857864376268},
		{X: 93.8360786437627, Y: 75.29357864376269},
		{X: 93.9775, Y: 75.235},
		{X: 94.11892135623732, Y: 75.29357864376269},
		{X: 94.17750000000001, Y: 75.435},
		{X: 94.11892135623731, Y: 75.57642135623732},
		{X: 93.39392135623731, Y: 76.30142135623731},
		{X: 93.2525, Y: 76.36},
		{X: 93.11107864376268, Y: 76.30142135623731},
	}
	us = s.P[0].PS
	if len(us) != len(expect) {
		t.Fatalf("expecting %d post union points, but see=%d points: got=%#v, want=%#v", len(expect), len(us), us, expect)
	}
	for i, got := range us {
		if want := expect[i]; !MatchPoint(got, want) {
			t.Errorf("point[%d]: got=%v, want=%v", i, got, want)
		}
	}

	pts = [][]Point{
		[]Point{
			{101.7525, 64.1893},
			{101.76714466094067, 64.15394466094068},
			{101.8025, 64.1393},
			{101.81027604609508, 64.14252094375422},
			{101.83785533905932, 64.15394466094068},
			{101.85249999999999, 64.1893},
			{101.83785533905932, 64.22465533905932},
			{101.8025, 64.2393},
			{101.7947239539049, 64.23607905624579},
			{101.76714466094067, 64.22465533905932},
		},
		[]Point{
			{101.79430104443772, 64.2386231905668},
			{101.7947239539049, 64.23607905624579},
			{101.81027604609508, 64.14252094375422},
			{101.81069895556227, 64.13997680943321},
			{101.92499895556227, 64.1589768094332},
			{101.90860104443772, 64.25762319056679},
		},
	}
	s = nil
	for i, ps := range pts {
		var err error
		s, err = s.Append(ps...)
		if err != nil {
			t.Fatalf("shape=%d failed import: %v", i, err)
		}
		s.Union()
		if err := s.chk(0); err != nil {
			t.Fatalf("shape=%d failed to correct bounding box: %v", i, err)
		}
		if len(s.P) != 1 {
			t.Fatalf("after shape=%d unioned, got=%d shapes, want=1: %v", i, len(s.P), s.P)
		}
	}
	expect = []Point{
		{X: 101.7525, Y: 64.1893},
		{X: 101.76714466094067, Y: 64.15394466094068},
		{X: 101.8025, Y: 64.1393},
		{X: 101.81027604609508, Y: 64.14252094375422},
		{X: 101.81069895556227, Y: 64.13997680943321},
		{X: 101.92499895556227, Y: 64.1589768094332},
		{X: 101.90860104443772, Y: 64.25762319056679},
		{X: 101.79430104443772, Y: 64.2386231905668},
		{X: 101.7947239539049, Y: 64.23607905624579},
		{X: 101.76714466094067, Y: 64.22465533905932},
	}
	us = s.P[0].PS
	if len(us) != len(expect) {
		t.Fatalf("expecting %d post union points, but see=%d points: got=%#v, want=%#v", len(expect), len(us), us, expect)
	}
	for i, got := range us {
		if want := expect[i]; !MatchPoint(got, want) {
			t.Errorf("point[%d]: got=%v, want=%v", i, got, want)
		}
	}
}

func TestMultiUnion(t *testing.T) {
	pts := [][]Point{
		[]Point{
			{102.02893679864614, 75.27038988683911},
			{102.0529527410619, 75.17135781555598},
			{102.11738387113262, 75.07488387113261},
			{102.21385781555601, 75.0104527410619},
			{102.31288988683914, 74.98643679864615},
			{103.99211011316088, 74.98643679864615},
			{104.09114218444398, 75.01045274106188},
			{104.18761612886738, 75.0748838711326},
			{104.2520472589381, 75.17135781555601},
			{104.27606320135385, 75.27038988683914},
			{104.27606320135385, 75.59961011316085},
			{104.25204725893812, 75.69864218444397},
			{104.18761612886739, 75.79511612886739},
			{104.09114218444398, 75.85954725893812},
			{103.99211011316088, 75.88356320135385},
			{102.31288988683914, 75.88356320135385},
			{102.21385781555601, 75.85954725893811},
			{102.1173838711326, 75.79511612886738},
			{102.05295274106189, 75.698642184444},
			{102.02893679864614, 75.59961011316088},
		},
		[]Point{
			{102.81391807012331, 75.435},
			{102.91308642139695, 75.19558642139695},
			{103.12379874257262, 75.09070903506165},
			{107.35620125742739, 75.09070903506165},
			{107.56691357860305, 75.19558642139695},
			{107.6660819298767, 75.435},
			{107.56691357860305, 75.67441357860305},
			{107.35620125742739, 75.77929096493835},
			{103.12379874257262, 75.77929096493835},
			{102.91308642139695, 75.67441357860305},
		},
		[]Point{
			{106.9053013422012, 76.07978005519425},
			{106.92763025915612, 75.92090155555957},
			{106.9718534860962, 75.76667683517547},
			{107.03711026821223, 75.62010770279622},
			{107.12213045646881, 75.48404695986365},
			{107.22525922961054, 75.36114287397216},
			{107.34448930337548, 75.25378763335226},
			{107.47749999999999, 75.1640707856479},
			{107.6217024175717, 75.0937385672482},
			{107.77428982006037, 75.0441599147826},
			{107.93229226724219, 75.01629982032648},
			{108.09263442120788, 75.01070054892804},
			{108.25219540431696, 75.02747108403595},
			{108.40786954353118, 75.06628500626057},
			{108.55662681880743, 75.12638684675595},
			{108.69557183899136, 75.2066067915617},
			{108.82200019731268, 75.30538345070099},
			{108.93345110958683, 75.42079424886047},
			{109.02775531057989, 75.5505928461318},
			{109.10307727628899, 75.69225286046283},
			{109.15795095032907, 75.84301704081045},
			{109.1913082790528, 75.99995093389592},
			{109.2025, 76.16},
			{109.1913082790528, 76.32004906610408},
			{109.15795095032907, 76.47698295918954},
			{109.10307727628899, 76.62774713953716},
			{109.02775531057989, 76.76940715386819},
			{108.93345110958683, 76.89920575113952},
			{108.82200019731268, 77.014616549299},
			{108.69557183899136, 77.1133932084383},
			{108.55662681880743, 77.19361315324404},
			{108.40786954353119, 77.25371499373942},
			{108.25219540431696, 77.29252891596404},
			{108.09263442120788, 77.30929945107195},
			{107.93229226724219, 77.30370017967351},
			{107.77428982006037, 77.2758400852174},
			{107.6217024175717, 77.2262614327518},
			{107.47749999999999, 77.1559292143521},
			{107.34448930337548, 77.06621236664773},
			{107.22525922961054, 76.95885712602784},
			{107.12213045646881, 76.83595304013635},
			{107.03711026821223, 76.69989229720377},
			{106.9718534860962, 76.55332316482452},
			{106.92763025915612, 76.39909844444043},
			{106.9053013422012, 76.24021994480574},
		},
		[]Point{
			{102.02893679864614, 76.54038988683912},
			{102.05295274106189, 76.441357815556},
			{102.1173838711326, 76.34488387113262},
			{102.21385781555601, 76.2804527410619},
			{102.31288988683914, 76.25643679864615},
			{103.99211011316088, 76.25643679864615},
			{104.09114218444398, 76.28045274106188},
			{104.18761612886739, 76.34488387113261},
			{104.25204725893812, 76.44135781555603},
			{104.27606320135385, 76.54038988683915},
			{104.27606320135385, 76.86961011316086},
			{104.2520472589381, 76.968642184444},
			{104.18761612886738, 77.0651161288674},
			{104.09114218444398, 77.12954725893812},
			{103.99211011316088, 77.15356320135385},
			{102.31288988683914, 77.15356320135385},
			{102.21385781555601, 77.1295472589381},
			{102.11738387113262, 77.06511612886739},
			{102.0529527410619, 76.96864218444402},
			{102.02893679864614, 76.86961011316089},
		},
	}
	var s *Shapes
	for i, ps := range pts {
		var err error
		s, err = s.Append(ps...)
		if err != nil {
			t.Fatalf("shape=%d failed import: %v", i, err)
		}
	}
	s.Union()
	if len(s.P) != 2 {
		t.Errorf("expecting 2 polygons to survive, see %d", len(s.P))
	}
	expect := []Point{
		{102.02893679864614, 75.27038988683911},
		{102.0529527410619, 75.17135781555598},
		{102.11738387113262, 75.07488387113261},
		{102.21385781555601, 75.0104527410619},
		{102.31288988683914, 74.98643679864615},
		{103.99211011316088, 74.98643679864615},
		{104.09114218444398, 75.01045274106188},
		{104.18761612886738, 75.0748838711326},
		{104.19818512966441, 75.09070903506166},
		{107.35620125742739, 75.09070903506165},
		{107.49067961679965, 75.1576426570299},
		{107.6217024175717, 75.0937385672482},
		{107.77428982006037, 75.0441599147826},
		{107.93229226724219, 75.01629982032648},
		{108.09263442120788, 75.01070054892804},
		{108.25219540431696, 75.02747108403595},
		{108.40786954353118, 75.06628500626057},
		{108.55662681880743, 75.12638684675595},
		{108.69557183899136, 75.2066067915617},
		{108.82200019731268, 75.30538345070099},
		{108.93345110958683, 75.42079424886047},
		{109.02775531057989, 75.5505928461318},
		{109.10307727628899, 75.69225286046283},
		{109.15795095032907, 75.84301704081045},
		{109.1913082790528, 75.99995093389592},
		{109.2025, 76.16},
		{109.1913082790528, 76.32004906610408},
		{109.15795095032907, 76.47698295918954},
		{109.10307727628899, 76.62774713953716},
		{109.02775531057989, 76.76940715386819},
		{108.93345110958683, 76.89920575113952},
		{108.82200019731268, 77.014616549299},
		{108.69557183899136, 77.1133932084383},
		{108.55662681880743, 77.19361315324404},
		{108.40786954353119, 77.25371499373942},
		{108.25219540431696, 77.29252891596404},
		{108.09263442120788, 77.30929945107195},
		{107.93229226724219, 77.30370017967351},
		{107.77428982006037, 77.2758400852174},
		{107.6217024175717, 77.2262614327518},
		{107.47749999999999, 77.1559292143521},
		{107.34448930337548, 77.06621236664773},
		{107.22525922961054, 76.95885712602784},
		{107.12213045646881, 76.83595304013635},
		{107.03711026821223, 76.69989229720377},
		{106.9718534860962, 76.55332316482452},
		{106.92763025915612, 76.39909844444043},
		{106.9053013422012, 76.24021994480574},
		{106.9053013422012, 76.07978005519425},
		{106.92763025915612, 75.92090155555957},
		{106.96823644259132, 75.77929096493835},
		{104.19818512966441, 75.77929096493835},
		{104.18761612886739, 75.79511612886739},
		{104.09114218444398, 75.85954725893812},
		{103.99211011316088, 75.88356320135385},
		{102.31288988683914, 75.88356320135385},
		{102.21385781555601, 75.85954725893811},
		{102.1173838711326, 75.79511612886738},
		{102.05295274106189, 75.698642184444},
		{102.02893679864614, 75.59961011316088},
	}
	us := s.P[0].PS
	if len(us) != len(expect) {
		t.Fatalf("expecting %d post union points, but see=%d points: got=%#v, want=%#v", len(expect), len(us), us, expect)
	}
	for i, got := range us {
		if want := expect[i]; !MatchPoint(got, want) {
			t.Errorf("point[%d]: got=%v, want=%v", i, got, want)
		}
	}
}

func TestInflate(t *testing.T) {
	var s *Shapes
	s = s.Builder([]Point{{1, 1}, {2, 1}, {2, 2}, {1, 2}}...)
	if err := s.Inflate(0, 2); err != nil {
		t.Fatalf("unable to inflate shape 0 by 1: %v", err)
	}
	expect := []Point{{0, 0}, {3, 0}, {3, 3}, {0, 3}}
	for i, got := range s.P[0].PS {
		if want := expect[i]; !MatchPoint(got, want) {
			t.Errorf("inflated point[%d]: got=%v, want=%v", i, got, want)
		}
	}
}

func TestNarrows(t *testing.T) {
	ts := [][]Point{
		{
			// not anti-parallel
			{0, 0}, {10, 0}, {3, 1}, {7, 1},
		},
		{
			{0, 0}, {10, 0}, {7, 1}, {3, 1},
			{2, 0}, {8, 0}, {7, 1}, {3, 1},
		},
		{
			{0, 0}, {0, 10}, {1, 7}, {1, 3},
			{0, 2}, {0, 8}, {1, 7}, {1, 3},
		},
		{
			{0, 0}, {0, 10}, {0, 10}, {4, 10},
			{0, 9}, {0, 10}, {0, 10}, {1, 10},
		},
		{
			{0, 0}, {10, 0}, {10, 0}, {10, 4},
			{9, 0}, {10, 0}, {10, 0}, {10, 1},
		},
		{
			{0, 0}, {0, 9.5}, {0.5, 10}, {4, 10},
			{0, 9}, {0, 9.5}, {0.5, 10}, {1, 10},
		},
	}
	same := func(a, b Point) bool {
		if math.Abs(a.X-b.X) > Zeroish {
			return false
		}
		if math.Abs(a.Y-b.Y) > Zeroish {
			return false
		}
		return true
	}
	rt := math.Sqrt(2)
	for i, v := range ts {
		hit, a, b, c, d := Narrows(v[0], v[1], v[2], v[3], rt)
		want := len(v) == 8
		if hit == want {
			if !want {
				continue
			}
		}
		if same(a, v[4]) && same(b, v[5]) && same(c, v[6]) && same(d, v[7]) {
			continue
		}
		t.Errorf("%d got %v [%v %v %v %v] want %v %v", i, hit, a, b, c, d, want, v[4:])
	}
}

func TestSlice(t *testing.T) {
	var s *Shapes
	s = s.Builder([]Point{{1, 1}, {2, 1}, {2, 2}, {1, 2}}...)
	lines, err := s.Slice(0, 0.2)
	if err != nil {
		t.Fatalf("failed to slice: %v", err)
	}
	want := []Line{
		{Point{1.1, 1.1}, Point{1.9, 1.1}},
		{Point{1.1, 1.2}, Point{1.9, 1.2}},
		{Point{1.1, 1.3}, Point{1.9, 1.3}},
		{Point{1.1, 1.4}, Point{1.9, 1.4}},
		{Point{1.1, 1.5}, Point{1.9, 1.5}},
		{Point{1.1, 1.6}, Point{1.9, 1.6}},
		{Point{1.1, 1.7}, Point{1.9, 1.7}},
		{Point{1.1, 1.8}, Point{1.9, 1.8}},
		{Point{1.1, 1.9}, Point{1.9, 1.9}},
	}
	if len(lines) != len(want) {
		t.Fatalf("got %d lines, wanted %d: %v, got: %v", len(lines), len(want), want, lines)
	}
	for i, line := range lines {
		w := want[i]
		if MatchPoint(w.From, line.From) && MatchPoint(w.To, line.To) {
			continue
		}
		t.Errorf("line[%d] got=%v, want=%v", i, line, w)
	}
	OptimizeLines(lines)
	for i, line := range lines {
		w := want[i]
		if i&1 != 0 {
			// Invert the direction because this is a
			// more optimal path.
			w.From, w.To = w.To, w.From
		}
		if MatchPoint(w.From, line.From) && MatchPoint(w.To, line.To) {
			continue
		}
		t.Errorf("line[%d] got=%v, want=%v", i, line, w)
	}

	lines, err = s.VSlice(0, 0.2)
	if err != nil {
		t.Fatalf("failed to slice: %v", err)
	}
	want = []Line{
		{Point{1.1, 1.1}, Point{1.1, 1.9}},
		{Point{1.2, 1.1}, Point{1.2, 1.9}},
		{Point{1.3, 1.1}, Point{1.3, 1.9}},
		{Point{1.4, 1.1}, Point{1.4, 1.9}},
		{Point{1.5, 1.1}, Point{1.5, 1.9}},
		{Point{1.6, 1.1}, Point{1.6, 1.9}},
		{Point{1.7, 1.1}, Point{1.7, 1.9}},
		{Point{1.8, 1.1}, Point{1.8, 1.9}},
		{Point{1.9, 1.1}, Point{1.9, 1.9}},
	}
	if len(lines) != len(want) {
		t.Fatalf("got %d lines, wanted %d: %v, got: %v", len(lines), len(want), want, lines)
	}
	for i, line := range lines {
		w := want[i]
		if MatchPoint(w.From, line.From) && MatchPoint(w.To, line.To) {
			continue
		}
		t.Errorf("line[%d] got=%v, want=%v", i, line, w)
	}

	s = nil
	s = s.Builder([]Point{{1, 1}, {1.4, 1}, {1.4, 1.4}, {1.6, 1.4}, {1.6, 1}, {2, 1}, {2, 2}, {1, 2}}...)
	lines, err = s.Slice(0, 0.2)
	if err != nil {
		t.Fatalf("failed to slice: %v", err)
	}
	if len(lines) != 13 {
		for i, line := range lines {
			t.Errorf("[%d] %v", i, line)
		}
		t.Fatalf("got %d lines, wanted %d", len(lines), 13)
	}

	s = nil
	s = s.Builder([]Point{
		{91.861, 64.235},
		{91.894, 64.169},
		{91.960, 64.136},
		{94.639, 64.136},
		{94.705, 64.169},
		{94.738, 64.235},
		{94.738, 66.854},
		{94.705, 66.920},
		{94.639, 66.953},
		{91.960, 66.953},
		{91.894, 66.920},
		{91.861, 66.854},
	}...).Builder([]Point{
		{92.078, 64.353},
		{92.078, 66.736},
		{94.521, 66.736},
		{94.521, 64.353},
	}...)
	lines, err = s.Slice(0, 0.05, 1)
	if err != nil {
		t.Errorf("slicing: %v", err)
	}
	if got, want := len(lines), 207; got != want {
		t.Errorf("slice generated bad lines: got=%d want=%d", got, want)
	}
}

func TestInnards(t *testing.T) {
	vs := []string{
		"########",
		" #     #",
		" # ### # ",
		"## # # #",
		"#  ### #",
		"##     #",
		"########",
	}
	for rev := 0; rev < 2; rev++ {
		p := &Shapes{}
		for i := 0; i < len(vs); i++ {
			index := len(vs) - 1 - i
			if rev == 1 {
				index = i
			}
			line := vs[i]
			y := float64(index)
			for j := 0; j < len(line); j++ {
				if line[j] != '#' {
					continue
				}
				x := float64(j)
				p = p.Builder([]Point{
					{x, y}, {x + 1, y}, {x + 1, y + 1}, {x, y + 1},
				}...)
			}
		}
		p.Union()
		if got, want := len(p.P), 4; got != want {
			t.Errorf("wrong number of polygons: got=%d want=%d", got, want)
		}
		for i, s := range p.P {
			if s.Hole != (i%2 == 1) {
				t.Errorf("%d should be a hole=%v", i, !s.Hole)
			}
		}
	}
}

func TestTransform(t *testing.T) {
	var s *Shapes
	s = s.Builder([]Point{{1, 1}, {3, 1}, {3, 2}, {1, 2}}...)
	r := s.Transform(Point{1, 2}, Point{3, 1}, math.Pi, 1)
	if r == nil || len(r.P) != 1 {
		t.Fatalf("single shape expected got something else: %#v", r)
	}
	for i, p := range s.P {
		c := r.P[i]
		if len(c.PS) != len(p.PS) {
			t.Errorf("shape=%d does not match: got=%#v want=%#v", i, p, c)
		}
		for j, pt := range p.PS {
			d := c.PS[j]
			if !MatchPoint(pt, d) {
				t.Errorf("transformed point[%d,%d] got=%v want=%v", i, j, pt, d)
			}
		}

	}
}
